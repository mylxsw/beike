
package models 

// !!! DO NOT EDIT THIS FILE

import (
	
	"context"
	"gopkg.in/guregu/null.v3"
	"github.com/mylxsw/eloquent/query"
	"github.com/iancoleman/strcase"
	"time"
)

func init() {

}



// DealHistory is a DealHistory object
type DealHistory struct {
	original *dealHistoryOriginal
	dealHistoryModel *DealHistoryModel

	
	Id int64 
	AreaId string 
	AreaName string 
	HouseId string 
	Name string 
	DealPrice float64 
	StickerPrice float64 
	UnitPrice float64 
	DealDate time.Time 
	DealDays int64 
	ChangePriceTimes int64 
	HouseType string 
	HouseSize float64 
	CreatedAt time.Time 
	UpdatedAt time.Time 
}

// SetModel set model for DealHistory
func (inst *DealHistory) SetModel(dealHistoryModel *DealHistoryModel) {
	inst.dealHistoryModel = dealHistoryModel
}

// dealHistoryOriginal is an object which stores original DealHistory from database
type dealHistoryOriginal struct {
	
	Id int64
	AreaId string
	AreaName string
	HouseId string
	Name string
	DealPrice float64
	StickerPrice float64
	UnitPrice float64
	DealDate time.Time
	DealDays int64
	ChangePriceTimes int64
	HouseType string
	HouseSize float64
	CreatedAt time.Time
	UpdatedAt time.Time
}

// Staled identify whether the object has been modified
func (inst *DealHistory) Staled() bool {
	if inst.original == nil {
		inst.original = &dealHistoryOriginal {}
	}

	
	if inst.Id != inst.original.Id {
		return true
	}
	if inst.AreaId != inst.original.AreaId {
		return true
	}
	if inst.AreaName != inst.original.AreaName {
		return true
	}
	if inst.HouseId != inst.original.HouseId {
		return true
	}
	if inst.Name != inst.original.Name {
		return true
	}
	if inst.DealPrice != inst.original.DealPrice {
		return true
	}
	if inst.StickerPrice != inst.original.StickerPrice {
		return true
	}
	if inst.UnitPrice != inst.original.UnitPrice {
		return true
	}
	if inst.DealDate != inst.original.DealDate {
		return true
	}
	if inst.DealDays != inst.original.DealDays {
		return true
	}
	if inst.ChangePriceTimes != inst.original.ChangePriceTimes {
		return true
	}
	if inst.HouseType != inst.original.HouseType {
		return true
	}
	if inst.HouseSize != inst.original.HouseSize {
		return true
	}
	if inst.CreatedAt != inst.original.CreatedAt {
		return true
	}
	if inst.UpdatedAt != inst.original.UpdatedAt {
		return true
	}

	return false
}

// StaledKV return all fields has been modified
func (inst *DealHistory) StaledKV() query.KV {
	kv := make(query.KV, 0)

	if inst.original == nil {
		inst.original = &dealHistoryOriginal {}
	}

	
	if inst.Id != inst.original.Id {
		kv["id"] = inst.Id
	}
	if inst.AreaId != inst.original.AreaId {
		kv["area_id"] = inst.AreaId
	}
	if inst.AreaName != inst.original.AreaName {
		kv["area_name"] = inst.AreaName
	}
	if inst.HouseId != inst.original.HouseId {
		kv["house_id"] = inst.HouseId
	}
	if inst.Name != inst.original.Name {
		kv["name"] = inst.Name
	}
	if inst.DealPrice != inst.original.DealPrice {
		kv["deal_price"] = inst.DealPrice
	}
	if inst.StickerPrice != inst.original.StickerPrice {
		kv["sticker_price"] = inst.StickerPrice
	}
	if inst.UnitPrice != inst.original.UnitPrice {
		kv["unit_price"] = inst.UnitPrice
	}
	if inst.DealDate != inst.original.DealDate {
		kv["deal_date"] = inst.DealDate
	}
	if inst.DealDays != inst.original.DealDays {
		kv["deal_days"] = inst.DealDays
	}
	if inst.ChangePriceTimes != inst.original.ChangePriceTimes {
		kv["change_price_times"] = inst.ChangePriceTimes
	}
	if inst.HouseType != inst.original.HouseType {
		kv["house_type"] = inst.HouseType
	}
	if inst.HouseSize != inst.original.HouseSize {
		kv["house_size"] = inst.HouseSize
	}
	if inst.CreatedAt != inst.original.CreatedAt {
		kv["created_at"] = inst.CreatedAt
	}
	if inst.UpdatedAt != inst.original.UpdatedAt {
		kv["updated_at"] = inst.UpdatedAt
	}

	return kv
}

// Save create a new model or update it 
func (inst *DealHistory) Save() error {
	if inst.dealHistoryModel == nil {
		return query.ErrModelNotSet
	}

	id, _, err := inst.dealHistoryModel.SaveOrUpdate(*inst)
	if err != nil {
		return err 
	}

	inst.Id = id
	return nil
}

// Delete remove a deal_history
func (inst *DealHistory) Delete() error {
	if inst.dealHistoryModel == nil {
		return query.ErrModelNotSet
	}

	_, err := inst.dealHistoryModel.DeleteById(inst.Id)
	if err != nil {
		return err 
	}

	return nil
}





type dealHistoryScope struct {
	name  string
	apply func(builder query.Condition)
}

var dealHistoryGlobalScopes = make([]dealHistoryScope, 0)
var dealHistoryLocalScopes = make([]dealHistoryScope, 0)

// AddGlobalScopeForDealHistory assign a global scope to a model
func AddGlobalScopeForDealHistory(name string, apply func(builder query.Condition)) {
	dealHistoryGlobalScopes = append(dealHistoryGlobalScopes, dealHistoryScope{name: name, apply: apply})
}

// AddLocalScopeForDealHistory assign a local scope to a model
func AddLocalScopeForDealHistory(name string, apply func(builder query.Condition)) {
	dealHistoryLocalScopes = append(dealHistoryLocalScopes, dealHistoryScope{name: name, apply: apply})
}

func (m *DealHistoryModel) applyScope() query.Condition {
	scopeCond := query.ConditionBuilder()
	for _, g := range dealHistoryGlobalScopes {
		if m.globalScopeEnabled(g.name) {
			g.apply(scopeCond)
		}
	}

	for _, s := range dealHistoryLocalScopes {
		if m.localScopeEnabled(s.name) {
			s.apply(scopeCond)
		}
	}

	return scopeCond
}

func (m *DealHistoryModel) localScopeEnabled(name string) bool {
	for _, n := range m.includeLocalScopes {
		if name == n {
			return true
		}
	}

	return false
}

func (m *DealHistoryModel) globalScopeEnabled(name string) bool {
	for _, n := range m.excludeGlobalScopes {
		if name == n {
			return false
		}
	}
	
	return true
}


type dealHistoryWrap struct { 	
	Id null.Int	
	AreaId null.String	
	AreaName null.String	
	HouseId null.String	
	Name null.String	
	DealPrice null.Float	
	StickerPrice null.Float	
	UnitPrice null.Float	
	DealDate null.Time	
	DealDays null.Int	
	ChangePriceTimes null.Int	
	HouseType null.String	
	HouseSize null.Float	
	CreatedAt null.Time	
	UpdatedAt null.Time
}

func (w dealHistoryWrap) ToDealHistory () DealHistory {
	return DealHistory {
		original: &dealHistoryOriginal { 
			Id: w.Id.Int64,
			AreaId: w.AreaId.String,
			AreaName: w.AreaName.String,
			HouseId: w.HouseId.String,
			Name: w.Name.String,
			DealPrice: w.DealPrice.Float64,
			StickerPrice: w.StickerPrice.Float64,
			UnitPrice: w.UnitPrice.Float64,
			DealDate: w.DealDate.Time,
			DealDays: w.DealDays.Int64,
			ChangePriceTimes: w.ChangePriceTimes.Int64,
			HouseType: w.HouseType.String,
			HouseSize: w.HouseSize.Float64,
			CreatedAt: w.CreatedAt.Time,
			UpdatedAt: w.UpdatedAt.Time,
		},
		
		Id: w.Id.Int64,
		AreaId: w.AreaId.String,
		AreaName: w.AreaName.String,
		HouseId: w.HouseId.String,
		Name: w.Name.String,
		DealPrice: w.DealPrice.Float64,
		StickerPrice: w.StickerPrice.Float64,
		UnitPrice: w.UnitPrice.Float64,
		DealDate: w.DealDate.Time,
		DealDays: w.DealDays.Int64,
		ChangePriceTimes: w.ChangePriceTimes.Int64,
		HouseType: w.HouseType.String,
		HouseSize: w.HouseSize.Float64,
		CreatedAt: w.CreatedAt.Time,
		UpdatedAt: w.UpdatedAt.Time,
	}
}


// DealHistoryModel is a model which encapsulates the operations of the object
type DealHistoryModel struct {
	db *query.DatabaseWrap
	tableName string

	excludeGlobalScopes []string
	includeLocalScopes []string
	
	query query.SQLBuilder
}

var dealHistoryTableName = "bk_deal_history"

func SetDealHistoryTable (tableName string) {
	dealHistoryTableName = tableName
}

// NewDealHistoryModel create a DealHistoryModel
func NewDealHistoryModel (db query.Database) *DealHistoryModel {
	return &DealHistoryModel {
		db: query.NewDatabaseWrap(db), 
		tableName: dealHistoryTableName,
		excludeGlobalScopes: make([]string, 0),
		includeLocalScopes: make([]string, 0),
		query: query.Builder(),
	}
}

// GetDB return database instance
func (m *DealHistoryModel) GetDB() query.Database {
	return m.db.GetDB()
}



func (m *DealHistoryModel) clone() *DealHistoryModel {
	return &DealHistoryModel{
		db: m.db, 
		tableName: m.tableName,
		excludeGlobalScopes: append([]string{}, m.excludeGlobalScopes...),
		includeLocalScopes: append([]string{}, m.includeLocalScopes...),
		query: m.query,
	}
}

// WithoutGlobalScopes remove a global scope for given query
func (m *DealHistoryModel) WithoutGlobalScopes(names ...string) *DealHistoryModel {
	mc := m.clone()
	mc.excludeGlobalScopes = append(mc.excludeGlobalScopes, names...)

	return mc
}

// WithLocalScopes add a local scope for given query
func (m *DealHistoryModel) WithLocalScopes(names ...string) *DealHistoryModel {
	mc := m.clone()
	mc.includeLocalScopes = append(mc.includeLocalScopes, names...)

	return mc
}

// Query add query builder to model
func (m *DealHistoryModel) Query(builder query.SQLBuilder) *DealHistoryModel {
	mm := m.clone()
	mm.query = mm.query.Merge(builder)

	return mm
}

// Find retrieve a model by its primary key
func (m *DealHistoryModel) Find(id int64) (DealHistory, error) {
	return m.First(m.query.Where("id", "=", id))
}

// Exists return whether the records exists for a given query
func (m *DealHistoryModel) Exists(builders ...query.SQLBuilder) (bool, error) {
	count, err := m.Count(builders...)
	return count > 0, err
}

// Count return model count for a given query
func (m *DealHistoryModel) Count(builders ...query.SQLBuilder) (int64, error) {
	sqlStr, params := m.query.
		Merge(builders...).
		Table(m.tableName).
		AppendCondition(m.applyScope()).
		ResolveCount()
	
	rows, err := m.db.QueryContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	defer rows.Close()

	rows.Next()
	var res int64
	if err := rows.Scan(&res); err != nil {
		return 0, err
	}

	return res, nil
}

func (m *DealHistoryModel) Paginate(page int64, perPage int64, builders ...query.SQLBuilder) ([]DealHistory, query.PaginateMeta, error) {
	if page <= 0 {
		page = 1
	}

	if perPage <= 0 {
		perPage = 15
	}

	meta := query.PaginateMeta {
		PerPage: perPage,
		Page: page,
	}

	count, err := m.Count(builders...)
	if err != nil {
		return nil, meta, err
	}

	meta.Total = count
	meta.LastPage = count / perPage
	if count % perPage != 0 {
		meta.LastPage += 1
	}


	res, err := m.Get(append([]query.SQLBuilder{query.Builder().Limit(perPage).Offset((page - 1) * perPage)}, builders...)...)
	if err != nil {
		return res, meta, err
	}

	return res, meta, nil
}

// Get retrieve all results for given query
func (m *DealHistoryModel) Get(builders ...query.SQLBuilder) ([]DealHistory, error) {
	b := m.query.Merge(builders...).Table(m.tableName).AppendCondition(m.applyScope())
	if len(b.GetFields()) == 0 {
		b = b.Select(
			"id",
			"area_id",
			"area_name",
			"house_id",
			"name",
			"deal_price",
			"sticker_price",
			"unit_price",
			"deal_date",
			"deal_days",
			"change_price_times",
			"house_type",
			"house_size",
			"created_at",
			"updated_at",
		)
	}

	fields := b.GetFields()
	selectFields := make([]query.Expr, 0)

	for _, f := range fields {
		switch strcase.ToSnake(f.Value) {
		 
		case "id":
			selectFields = append(selectFields, f) 
		case "area_id":
			selectFields = append(selectFields, f) 
		case "area_name":
			selectFields = append(selectFields, f) 
		case "house_id":
			selectFields = append(selectFields, f) 
		case "name":
			selectFields = append(selectFields, f) 
		case "deal_price":
			selectFields = append(selectFields, f) 
		case "sticker_price":
			selectFields = append(selectFields, f) 
		case "unit_price":
			selectFields = append(selectFields, f) 
		case "deal_date":
			selectFields = append(selectFields, f) 
		case "deal_days":
			selectFields = append(selectFields, f) 
		case "change_price_times":
			selectFields = append(selectFields, f) 
		case "house_type":
			selectFields = append(selectFields, f) 
		case "house_size":
			selectFields = append(selectFields, f) 
		case "created_at":
			selectFields = append(selectFields, f) 
		case "updated_at":
			selectFields = append(selectFields, f)
		}
	}

	var createScanVar = func(fields []query.Expr) (*dealHistoryWrap, []interface{}) {
		var dealHistoryVar dealHistoryWrap
		scanFields := make([]interface{}, 0)

		for _, f := range fields {
			switch strcase.ToSnake(f.Value) {
			 
			case "id":
				scanFields = append(scanFields, &dealHistoryVar.Id) 
			case "area_id":
				scanFields = append(scanFields, &dealHistoryVar.AreaId) 
			case "area_name":
				scanFields = append(scanFields, &dealHistoryVar.AreaName) 
			case "house_id":
				scanFields = append(scanFields, &dealHistoryVar.HouseId) 
			case "name":
				scanFields = append(scanFields, &dealHistoryVar.Name) 
			case "deal_price":
				scanFields = append(scanFields, &dealHistoryVar.DealPrice) 
			case "sticker_price":
				scanFields = append(scanFields, &dealHistoryVar.StickerPrice) 
			case "unit_price":
				scanFields = append(scanFields, &dealHistoryVar.UnitPrice) 
			case "deal_date":
				scanFields = append(scanFields, &dealHistoryVar.DealDate) 
			case "deal_days":
				scanFields = append(scanFields, &dealHistoryVar.DealDays) 
			case "change_price_times":
				scanFields = append(scanFields, &dealHistoryVar.ChangePriceTimes) 
			case "house_type":
				scanFields = append(scanFields, &dealHistoryVar.HouseType) 
			case "house_size":
				scanFields = append(scanFields, &dealHistoryVar.HouseSize) 
			case "created_at":
				scanFields = append(scanFields, &dealHistoryVar.CreatedAt) 
			case "updated_at":
				scanFields = append(scanFields, &dealHistoryVar.UpdatedAt)
			}
		}

		return &dealHistoryVar, scanFields
	}
	
	sqlStr, params := b.Fields(selectFields...).ResolveQuery()
	
	rows, err := m.db.QueryContext(context.Background(), sqlStr, params...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	dealHistorys := make([]DealHistory, 0)
	for rows.Next() {
		dealHistoryVar, scanFields := createScanVar(fields)
		if err := rows.Scan(scanFields...); err != nil {
			return nil, err
		}

		dealHistoryReal := dealHistoryVar.ToDealHistory()
		dealHistoryReal.SetModel(m)
		dealHistorys = append(dealHistorys, dealHistoryReal)
	}

	return dealHistorys, nil
}

// First return first result for given query
func (m *DealHistoryModel) First(builders ...query.SQLBuilder) (DealHistory, error) {
	res, err := m.Get(append(builders, query.Builder().Limit(1))...)
	if err != nil {
		return DealHistory{}, err 
	}

	if len(res) == 0 {
		return DealHistory{}, query.ErrNoResult
	}

	return res[0], nil
}

// Create save a new deal_history to database
func (m *DealHistoryModel) Create(kv query.KV) (int64, error) {
	
	if _, ok := kv["created_at"]; !ok {
		kv["created_at"] = time.Now()
	}
	
	
	if _, ok := kv["updated_at"]; !ok {
		kv["updated_at"] = time.Now()
	}
	

	sqlStr, params := m.query.Table(m.tableName).ResolveInsert(kv)

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.LastInsertId()
}

// SaveAll save all deal_historys to database
func (m *DealHistoryModel) SaveAll(dealHistorys []DealHistory) ([]int64, error) {
	ids := make([]int64, 0)
	for _, dealHistory := range dealHistorys {
		id, err := m.Save(dealHistory)
		if err != nil {
			return ids, err
		}

		ids = append(ids, id)
	}

	return ids, nil
}

// Save save a deal_history to database
func (m *DealHistoryModel) Save(dealHistory DealHistory) (int64, error) {
	return m.Create(dealHistory.StaledKV())
}

// SaveOrUpdate save a new deal_history or update it when it has a id > 0
func (m *DealHistoryModel) SaveOrUpdate(dealHistory DealHistory) (id int64, updated bool, err error) {
	if dealHistory.Id > 0 {
		_, _err := m.UpdateById(dealHistory.Id, dealHistory)
		return dealHistory.Id, true, _err
	}

	_id, _err := m.Save(dealHistory)
	return _id, false, _err
}

// UpdateFields update kv for a given query
func (m *DealHistoryModel) UpdateFields(kv query.KV, builders ...query.SQLBuilder) (int64, error) {
	if len(kv) == 0 {
		return 0, nil
	}

	
	kv["updated_at"] = time.Now()
	

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).
		Table(m.tableName).
		ResolveUpdate(kv)

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// Update update a model for given query
func (m *DealHistoryModel) Update(dealHistory DealHistory) (int64, error) {
	return m.UpdateFields(dealHistory.StaledKV())
}

// UpdateById update a model by id
func (m *DealHistoryModel) UpdateById(id int64, dealHistory DealHistory) (int64, error) {
	return m.Query(query.Builder().Where("id", "=", id)).Update(dealHistory)
}



// Delete remove a model
func (m *DealHistoryModel) Delete(builders ...query.SQLBuilder) (int64, error) {
	
	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).Table(m.tableName).ResolveDelete()

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
	
}

// DeleteById remove a model by id
func (m *DealHistoryModel) DeleteById(id int64) (int64, error) {
	return m.Query(query.Builder().Where("id", "=", id)).Delete()
}


